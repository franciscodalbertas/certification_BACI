---
title: "Análise preliminar"
author: "Francisco d'Albertas & Patricia Ruggiero"
date: "21/09/2021"
output: 
  html_document:
    toc: true
    theme: united
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = F,warning = F)


load("D:/Doutorado/cap3/certification_BACI/preliminary_analysis.RData")

### pra nao rodar modelos novamente
# rmarkdown::render(input = "preliminary_analysis.Rmd",output_file = "preliminary_analysis.html",envir = parent.frame())

```

## Objetivos

Depois de ter excecutado matching, analisar a efetividade da certificação usando análise de regressão em painel.

A idéia é Analisar os dados com a área das propriedades em log e na escala original (variáveis usadas para realizar o matching).

Os modelos foram construídos de duas formas: 

- através de uma abordagem bayesiana, que segue a lógica formal dos modelos que a gente usa na ecologia (usei como referência os scripts do artigo *GLMM BACI environmental impact analysis shows coastal dune restoration reduces seed predation on an endangered plant, de Pardini et al., 2018.*.  

- Modelo da econometria

```{r include=FALSE}

# p <- 'D:\\Doutorado\\cap3\\matching'
# 
# cont <- read.csv(file.path(p,'control.csv'))
# 
# treat <- read.csv(file.path(p,'treatment.csv'))
# 

data <- rbind(cont,treat)


```


## Desmatamento

Calculei a taxa de desmatamento como a área desmatada em um dado ano dividida pela área de floresta no respectivo ano. Usar a área do ano anterior gera uma série de erros (**discutir isso**)




```{r include=FALSE}

# Abrindo planilha de dados de desmatamento:

# p2 <- "D:\\Doutorado\\cap3\\metricas"
# 
# 
# desm_cert <- read.csv(file.path(p2,"taxa_desmatamento_area_veg_cert.csv"))
# 
# desm_ncert <- read.csv(file.path(p2,"taxa_desmatamento_area_veg_ncert.csv"))
# 
# 
# # subset
# 
# desm_cert <- desm_cert[desm_cert$COD_IMOVEL %in% data$COD_IMOVEL,]
# 
# desm_ncert <- desm_ncert[desm_ncert$COD_IMO %in% data$COD_IMOVEL,]
# 
# # incluindo tratamento
# 
# desm_cert$treatment <- 'certified'
# desm_ncert$treatment <- 'n_certified'
# 
# # dados de interesse
# 
# desm_cert <- desm_cert[,c(2,13,18,19)]
# desm_ncert <- desm_ncert[,c(2,18,23,24)]
# 
# names(desm_ncert) <- names(desm_cert)
# 
# desm <- rbind(desm_ncert,desm_cert)
# 
# # excluindo 1996
# 
# desm <- desm[desm$year!=1996,]
# 
# 
# 
# # codigo imovel como fator
# 
# desm$COD_IMOVEL <- as.factor(desm$COD_IMOVEL)
# 
# ```
# 
# Criando '*dummy*' para antes e depois da certificação:
# 
# ```{r}
# 
# desm$certification <- NA
# 
# desm$certification[desm$year<=2007] <- "before"
# desm$certification[desm$year>2007] <- "after"
# 
# # ano tem que ser fatorial
# 
# desm$year <- as.factor(desm$year)
# 
# ```
# 
# 
# ### Modelo usando variaveis pareadas com área em escala original
# 
# Estou explorando usar modelos bayesianos. Usar cadeias de markov demora muito, logo para análise exploratória, estou usando um pacote que usa aproximação de laplace. Esse pacote não tem uma familia com zero e um inflated beta. Tenho que fazer uma transformação na variável resposta para não ter valores 0 e 1.
# 
# 
# ```{r}
# y.transf.betareg <- function(y){
#     n.obs <- sum(!is.na(y))
#     (y * (n.obs - 1) + 0.5) / n.obs
# }
# 
# 
# desm$y <- y.transf.betareg(desm$def_rate)
#
# mudar ordem do tempo antes, depois

desm$certification <- relevel(as.factor(desm$certification),ref = "before")

```

Como eu não consigo graficar os resultados do modelo econométrico, os dados brutos plotados podem ser usados para ilustrar o problema:

```{r echo=FALSE, fig.align='center'}

library(doBy)
library(ggplot2)

averages_bruto <- summaryBy(data = desm,def_rate~treatment+year) 


def_year_bruto <- ggplot(data = desm, aes(x = year, y = def_rate))+
  geom_point(aes(colour=treatment),alpha = 0.05)+
  geom_line(data=averages_bruto,aes(x = year, y = def_rate.mean,group=treatment,colour=treatment),
            size=0.8)+
  #geom_ribbon(aes(x = year, ymin = lo.m01, ymax = up.m01), alpha = 1)+
  #facet_wrap(~COD_IMOVEL, scales = "free") +
  xlab("Year")+
  ylab("deforestation rate")+
  theme_bw()+
  ylim(0,0.5)+
  scale_x_discrete(labels=c(seq(97,99,1),seq(0,18,1)))+
  geom_vline(xintercept = 10,linetype = "dashed",colour="red",size=1)


# esse nao vale a pena nem plotar!

# BACI_bruto <- summaryBy(data = desm,def_rate~treatment+certification,FUN = c(mean,sd))
# 
# BACI_bruto$se <- BACI_bruto$def_rate.sd/sqrt(length(desm))
# 
# BACI_bruto$ymin <- BACI_bruto$def_rate.mean-BACI_bruto$se
# 
# BACI_bruto$ymax <- BACI_bruto$def_rate.mean+BACI_bruto$se
# 
# def_BACI_bruto <- ggplot(BACI_bruto, aes(x=certification, y=def_rate.mean, group=treatment, color=treatment)) + 
#   geom_line()+
#   geom_pointrange(aes(ymin=ymin, ymax=ymax),position=position_dodge(0.05))
   

def_year_bruto

```


### Modelando os dados como "ecólogos fariam"

```{r}




library(INLA)

# documentação da função
#names(inla.models()$likelihood)
#inla.doc("familyname")

# deu certo!

# m01 <- inla(y~certification*treatment+f(COD_IMOVEL,model = "iid")+f(year,model = "iid"),
#   family = "beta",
#   data = desm,
#   control.predictor = list(link = 1),
#   verbose=TRUE
# )


summary(m01)

```


Plotando o tamanho do efeito:

```{r include=FALSE}

library(doBy)

averages <- summaryBy(data = desm,mean.m01~treatment+year) 


library(ggplot2)

# pensar em como plotar essas caralhas! ta calculando varios, tem q pegar efeito
# medio! tem q calcular media dos sites!! e ai ic tb!!

def_year <- ggplot(data = desm, aes(x = year, y = y))+
  #geom_point(aes(colour=treatment),alpha = 0.2)+
  geom_line(data=averages,aes(x = year, y = mean.m01.mean,group=treatment,colour=treatment))+
  #geom_ribbon(aes(x = year, ymin = lo.m01, ymax = up.m01), alpha = 1)+
  #facet_wrap(~COD_IMOVEL, scales = "free") +
  xlab("Year")+
  ylab("deforestation rate")+
  theme_bw()+
  ylim(0,0.05)+
  scale_x_discrete(labels=c(seq(97,99,1),seq(0,17,1)))+
  geom_vline(xintercept = 10,linetype = "dashed",colour="red",size=1)

# isso uso pra plotar tamanho do efeito!

fit_fixed <- data.frame(m01$summary.fixed )

fit_fixed$coef <- row.names(fit_fixed)

l.fim <- c("time","treatment:time","treatment")

# my.theme = theme_bw(base_size = 12)+theme(panel.grid.major = element_blank(),panel.grid.minor = element_blank()) + 
#   theme(axis.title.x = element_text( face="bold"))


es.plot <- ggplot(data = fit_fixed[-1,],aes(x=coef,y = mean))+
    #geom_point(colour = "black", size = 10) +
    geom_pointrange(aes(ymin=X0.025quant,ymax=X0.975quant),size=0.1,color="black") + 
    coord_flip()+
    scale_x_discrete("",labels=l.fim)+
    scale_y_continuous("Standardized coeficients")+
    geom_hline(yintercept = 0, linetype="dotted",color = "black", size=0.5) +
    #ggtitle("Model ajusted with Yield max (R²=0.46)")+
    #my.theme+
    theme(legend.position = "none")+
    #### mudando facet_Grid label
    theme(
      strip.background =  element_blank(),strip.text.x = element_text(
        size = 12, color = "black", face = "bold"
      )
    )


# e pra plotar antes e depois grafico com ic + media?

# teria q calcular media por tratamento e fase (antes e depois)
# IC valeria

BACI <- summaryBy(data = desm,mean.m01~treatment+certification,FUN = c(mean,sd))

BACI$se <- BACI$mean.m01.sd/sqrt(length(desm))

BACI$ymin <- BACI$mean.m01.mean-BACI$se

BACI$ymax <- BACI$mean.m01.mean+BACI$se

def_BACI <- ggplot(desm, aes(x=certification, y=mean.m01, group=treatment, color=treatment)) + 
  geom_line(width=0.2,position=position_dodge(0.05))+
  geom_point(data = BACI,aes(x = certification,y=mean.m01.mean, group=treatment, color=treatment)
             ,position=position_dodge(0.05))+
  geom_linerange(data = desm,aes(ymin=lo.m01, ymax=up.m01), width=0.2,position=position_dodge(0.05))+
  ylim(0,0.025)

```


```{r echo=FALSE, fig.align='center'}

es.plot

```

### Modelando os dados usando modelo econométrico

```{r}

library(plm)

m02 <- plm(formula = y ~ treatment*certification, data = desm, effect="individual",model = "within", index = c("COD_IMOVEL","year"))

summary(m02)

library(clubSandwich)

m02c <- coef_test(m02, vcovCR(m02, cluster = desm$COD_IMOVEL, type = "CR1S"))

m02c

```

**O resultado não distoa muito, mas o sinal dos coeficientes é diferente!!**. Embora seja uma tendência marginal, há uma tendência de aumento no desmatamento pós 2017, então para mim o coeficiente negativo para a variável time (antes ou depois de 2017) faz mais sentido.

Plotando o tamanho do efeito:

```{r echo=FALSE}

library(jtools)

es_plm <- plot_coefs(m02)
l.plm <- c("treatment:time","time")
es_plm+scale_y_discrete("",labels=l.plm)

#head(predict(m02))

```




